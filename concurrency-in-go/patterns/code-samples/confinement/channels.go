package main

import "fmt"

func main() {
	chanOwner := func() <-chan int {
		// Инициализируем канал в пределах лексической области (скоупа) функции
		// chanOwner. Это ограничивает область действия аспекта записи в канал
		// results замыканием, определённым ниже. Другими словами, это изолирует
		// аспект записи канала, чтобы предотвратить запись в него другими
		// горутинами
		results := make(chan int, 5)

		go func() {
			defer close(results)

			for i := 0; i <= 5; i++ {
				results <- i
			}
		}()

		return results
	}

	// Получаем копию int-канала только для чтения. Объявляя, что единственное
	// использование, которое нам требуется, — это доступ для чтения, мы
	// изолируем использование канала в функции consume только чтениями
	consumer := func(results <-chan int) {
		for result := range results {
			fmt.Printf("Received: %d\n", result)
		}

		fmt.Println("Done receiving!")
	}

	// Получаем аспект чтения канала и можем передать его в consumer, который
	// ничего не сможет делать, кроме как читать из него. Ещё раз, это изолирует
	// main-горутину так, чтобы она могла только читать из канала
	results := chanOwner()
	consumer(results)
}
