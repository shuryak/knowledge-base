package main

// Наша функция or, которая принимает произвольный слайс каналов и возвращает
// одиночный канал
func or(channels ...<-chan interface{}) <-chan interface{} {
	switch len(channels) {
	// Поскольку это рекурсивная функция, мы должны задать базовый случай.
	// В первом случае, если произвольный слайс пустой, мы просто вернём
	// nil-канал. Это консистентно с общим ожидаемым поведением функции:
	// в случае, когда мы не передали ни один канал, мы не ожидаем, что
	// составной канал что-то будет делать
	case 0:
		return nil
	// Второй базовый случай: если произвольный слайс состоит только из одного
	// элемента, мы просто вернём этот же элемент
	case 1:
		return channels[0]
	}

	orDone := make(chan interface{})

	// Основное тело функции, где происходит рекурсия. Мы создаём горутину,
	// чтобы мы могли ожидать сообщения на наших каналах без блокировки
	go func() {
		defer close(orDone)

		switch len(channels) {
		// Из-за того, как мы выполняем рекурсию, каждый рекурсивный вызов or
		// будет иметь, по крайней мере, два канала. В качестве оптимизации,
		// чтобы ограничить количество создаваемых горутин, мы помещаем здесь
		// особый случай для вызовов or только с двумя каналами
		case 2:
			select {
			case <-channels[0]:
			case <-channels[1]:
			}
		// Здесь мы рекурсивно создаём or-канал из всех каналов из нашего
		// слайса, начиная с индекса 3, а затем выполняем select по ним. Это
		// рекуррентное соотношение деструктурирует остальную часть среза на
		// or-каналы, чтобы сформировать дерево, из которого вернётся первый
		// сигнал. Мы также передаём канал orDone, чтобы когда горутины вверху
		// дерева завершатся, горутины внизу также завершились.
		default:
			select {
			case <-channels[0]:
			case <-channels[1]:
			case <-channels[2]:
			case <-or(append(channels[3:], orDone)...):
			}
		}
	}()

	return orDone
}
