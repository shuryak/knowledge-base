# Конкурентность в Go <!-- omit in toc -->

## Содержание <!-- omit in toc -->

- [Введение в конкурентность](#введение-в-конкурентность)
  - [Состояния гонки (Race Conditions)](#состояния-гонки-race-conditions)
  - [Атомарность (Atomicity)](#атомарность-atomicity)
  - [Синхронизация доступа к памяти](#синхронизация-доступа-к-памяти)

## Введение в конкурентность

"Concurrency" обычно переводится с английского как "параллелизм", но в контексте
программирования правильнее переводить это слово как "конкурентность".

### Состояния гонки (Race Conditions)

Состояние гонки возникает когда две или более операции должны исполняться в
правильной последовательности, но программа написана не гарантируя этот порядок.

В большинстве случаев это проявляется в так называемой *гонке данных* (*data
race*), когда одна конкурентная операция пытается прочитать переменную, пока в
это же неопределённое время другая конкурентная операция пытается записать
значение в эту же переменную.

Пример ([`code-samples/race-cond-1.go`](code-samples/race-cond-1.go)):

```go
var data int
go func() {
    data++
}()
if data == 0 {
    fmt.Printf("the value is %d.\n", data)
}
```

Существуют 3 возможных исхода:

- Ничего не распечатается. В этом случае строчка 3 выполнилась раньше строчки 5.
- Распечатается `the value is 0`. В этом случае, строчки 5 и 6 выполнились
  раньше строчки 3.
- Распечатается `the value is 1`. В этом случае, строчка 5 выполнилась раньше
  строчки 3, но строчка 3 выполнилась позже строчки 6.

> Полезно представлять, что между операциями проходит большой промежуток
> времени.
>
> *Что, если между вызовом горутины и её запуском проходит час?*
>
> *Что, если пройдёт час между успешным выполнением горутины и достижением
> программой оператора `if`?*

> Конечно же, выражения наподобие `time.Sleep()` никак не решают проблему. Они
> лишь делают её возникновение менее вероятным, но от этого программа не
> становится логически более корректной.

### Атомарность (Atomicity)

*Атомарное* — неделимое, непрерывное в текущем контексте (context) или области
(scope).

> Операции, которые являются атомарными в контексте запущенного процесса, могут
> не быть атомарными в контексте операционной системы; операции, которые
> являются атомарными в контексте операционной системы, могут не быть атомарными
> в контексте машины; операции, которые являются атомарными в контексте машины,
> могут не быть атомарными в контексте приложения. Другими словами, атомарность
> операции может меняться в зависимости от текущей области.
>
> Этот факт может работать как на нас, так и против нас!

Понятия «неделимое» и «непрерывное» означают, что в определённом нами контексте
произойдёт действие, и никакое другое действие не произойдёт в этом контексте
одновременно.

Пример:

```go
i++
```

Эта операция может показаться атомарной, однако при более детальном анализе её
можно разбить на несколько операций:

- Получить значение `i`;
- Инкрементировать значение `i`;
- Сохранить значение `i`.

Каждая из этих отдельных операций атомарная, но их комбинация может не быть
атомарной. Всё зависит от контекста. Это показывает интересное свойство
атомарных операций: их комбинация необязательно производит более крупную
атомарную операцию. Получится ли из комбинации атомарная операция зависит от
того, в каком контексте мы хотим, чтобы она была атомарной. Если наш контекст
представляет собой программу без конкурентных процессов, тогда этот код
атомарный в этом контексте. Если наш контекст — это горутина, которая не
предоставляет `i` другим горутинам, в этом случае код тоже будет атомарным.

> Если что-то атомарно, то это безопасно в конкурентных контекстах.

Большинство операторов не атомарны, не говоря уже о функциях и методах. Но если
атомарность является ключом к составлению логически верных программ, а
большинство операторов не являются атомарными, то как нам согласовать эти два
утверждения? Мы можем добиться атомарности, используя различные способы. Затем
уже, самое важное — понять, какие области кода должны быть атомарными.

### Синхронизация доступа к памяти

Пусть имеется гонка данных: 2 конкурентных процесса пытаются получить доступ к
одной области памяти, и способ, с помощью которого они получают доступ к
памяти, не атомарный
([`code-samples/race-cond-2.go`](code-samples/race-cond-2.go)):

```go
var data int
go func() {
  data++
}()
if data == 0 {
  fmt.Println("the value is 0.")
} else {
  fmt.Printf("the value is %d.\n", data)
}
```

Сейчас вывод полностью неопределённый (недетерминированный).

*Критическая секция* (*critical section*) — секция программы, которой требуются
эксклюзивные права на общий (shared) ресурс.

У нас в примере 3 критические секции:

- Горутина, которая инкрементирует переменную `data`;
- Выражение `if`, которое проверяет, равно ли значение `data` нулю;
- Выражение `fmt.Printf`, которое получает значение `data` для вывода.

Существуют различные способы защитить критические секции программы, и Go имеет
несколько лучших идей, как это сделать. Но один из способов — синхронизировать
доступ к памяти между критическими секциями.

Следующий код
([`code-samples/mem-access-sync.go`](code-samples/mem-access-sync.go)) не
идиоматичен для Go, но он очень просто демонстрирует синхронизацию доступа к
памяти:

```go
// Переменная, которая будет разрешать/запрещать доступ к памяти переменной data
var memoryAccess sync.Mutex
var data int
go func() {
  // Объявляем, что пока мы не объявим обратное, горутина должна иметь
  // эксклюзивный доступ к этой памяти
  memoryAccess.Lock()
  data++
  // Объявляем, что горутина завершила работу с этой памятью
  memoryAccess.Unlock()
}()
// Снова объявляем, что следующие условные выражения должны иметь эксклюзивный
// доступ к памяти переменной data
memoryAccess.Lock()
if data == 0 {
  fmt.Printf("the value is %d.\n", data)
} else {
  fmt.Printf("the value is %d.\n", data)
}
// Снова объявляем, что работа с памятью переменной data завершена
memoryAccess.Unlock()
```

Здесь мы создали конвенцию для разработчиков, которой следует придерживаться:
каждый раз, когда разработчик хочет получить доступ к памяти переменной `data`,
он должен сначала вызвать `Lock`, а как только он закончит работу с этой
памятью, вызвать `Unlock`. Код между двумя этими выражениями будет иметь
эксклюзивный доступ к памяти переменной `data`.

> Конвенции — это хорошо, но их также легко игнорировать — особенно в разработке
> ПО, где требования бизнеса иногда перевешивают благоразумие.

Хотя мы и решили проблему гонки данных, мы всё ещё не избежали состояния гонки.
Порядок операций в программе всё ещё недетерминирован. Мы лишь немного сузили
рамки неопределённости. В этом примере либо горутина будет выполнена
первой, либо блоки `if` и `else`.

Синхронизация доступа к памяти таким образом влияет на производительность
программы. Вызов `Lock` делает программу *медленной*. Каждый раз, когда мы
выполняет одну из таких операций, программа приостанавливается на некоторый
период времени. Вставют два вопроса:

- Являются ли мои критические секции многократными входами/выходами?
- Какого размера должны быть мои критические секции?

Ответить на эти 2 вопроса в контексте вашей программы — это искусство, и это
добавляет сложности в синхронизацию доступа к памяти.
